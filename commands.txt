docker build -t emotionrecognition-app:latest .

docker run -p 5000:5000 -e DAGSHUB_TOKEN=<token>  emotionrecognition-app:latest



----------------------------------------------------------------------------------
*********Setup required before moving to EKS deployment*********
----------------------------------------------------------------------------------
* Run the following in PowerShell to see the AWS CLI path being used: Get-Command aws
If the path points to your Anaconda environment (e.g., C:\Users\Personal\anaconda3\...), it’s a conflicting installation.

* Uninstall Python-Based AWS CLI(Remove the conflicting AWS CLI from your Python environment): pip uninstall awscli
* Verify it's uninstalled: aws --version
* Update Environment Variables:
> Make sure the .msi AWS CLI path is in your system PATH (usually installed at C:\Program Files\Amazon\AWSCLIV2\aws.exe).
> Add it to your PATH if missing: Open Control Panel > System > Advanced System Settings > Environment Variables. Under "System Variables," find Path, and add the AWS CLI path: C:\Program Files\Amazon\AWSCLIV2\
> Test AWS CLI Again: aws --version
----------------------------------------------------------------------------------

* Download kubectl: Invoke-WebRequest -Uri "https://dl.k8s.io/release/v1.28.2/bin/windows/amd64/kubectl.exe" -OutFile "kubectl.exe"
* Locate the Download: Get-Location
* Move kubectl.exe to a directory in your system PATH, such as C:\Windows\System32: Move-Item -Path .\kubectl.exe -Destination "C:\Windows\System32"
* Test if kubectl is properly installed: kubectl version --client


* Download eksctl: Invoke-WebRequest -Uri "https://github.com/weaveworks/eksctl/releases/download/v0.158.0/eksctl_Windows_amd64.zip" -OutFile "eksctl.zip"
* Extract eksctl: Expand-Archive -Path .\eksctl.zip -DestinationPath .
* Move the extracted eksctl.exe file to C:\Windows\System32 or any folder in your system PATH: Move-Item -Path .\eksctl.exe -Destination "C:\Windows\System32\eksctl.exe"
----------------------------------------------------------------------------------
* Verify AWS CLI: aws --version
* Verify kubectl: kubectl version --client
* Verify eksctl: eksctl version
----------------------------------------------------------------------------------

AWS Configure on terminal
(atlas) PS D:\AIML\EmotionRecognition> aws configure --profile myprof
AWS Access Key ID [None]: 
AWS Secret Access Key [None]: 
Default region name [None]: 
Default output format [None]: 

aws configure set region us-east-1

39. Create an EKS cluster:
    eksctl create cluster --name flask-app-cluster --region us-east-1 --nodegroup-name flask-app-nodes --node-type t3.small --nodes 1 --nodes-min 1 --nodes-max 1 --managed

    eksctl create cluster --name flask-app-cluster --region us-east-1 --version 1.31 --nodegroup-name flask-app-nodes --node-type t3.small --nodes 1 --nodes-min 1 --nodes-max 1 --managed --node-ami-family AmazonLinux2023


40. Update kubectl Config(Once the cluster is created, eksctl will automatically update your kubectl config file. However, you can verify and set it manually using:)
aws eks --region us-east-1 update-kubeconfig --name flask-app-cluster (This ensures your kubectl is pointing to the correct cluster.)

41. Check EKS Cluster Configuration Ensure you can access your EKS cluster by running
    aws eks list-clusters

42. Delete cluster(optional):
    eksctl delete cluster --name flask-app-cluster --region us-east-1

    Also, verify cluster deletion:
    eksctl get cluster --region us-east-1

43. Verify the cluster status:
    aws eks --region us-east-1 describe-cluster --name flask-app-cluster --query "cluster.status"


44. Check cluster connectivity:
kubectl get nodes

45. Check the namespaces:
kubectl get namespaces

46. Verify the deployment:
kubectl get pods
kubectl get svc

47. Deploy the app on EKS via CICD pipeline 
  >> edit ci.yaml, deployment.yaml, dockerfile
  >> Also edit the security group for nodes and edit inbound rule for 5000 port
  >> Do git add commit push


48. Once the LoadBalancer service is up, get the external IP:
kubectl get svc flask-app-service

49. Try externa-ip:5000 directly on url or on terminal : curl http://external-ip:5000
curl http://a6bf6255d5f61470c9782b8955c98271-1409247973.us-east-1.elb.amazonaws.com:5000
















----------------------------------------------------------------------------------

AWS Resource Cleanup:

* Delete deployment - kubectl delete deployment flask-app
* Delete service - kubectl delete service flask-app-service
* Delete env var - kubectl delete secret capstone-secret
* Delete EKS Cluster - eksctl delete cluster --name flask-app-cluster --region us-east-1
* Verify Cluster Deletion - eksctl get cluster --region us-east-1
* Delete artifacts of ECR and S3 (optional - delete ECR and S3)
* Validate if Cloud Formation stacks are deleted.
* Confirm service termination on AWS support chat.




----------------------------------------------------------------------------------


***** How Is CloudFormation Related to EKS? *****

What Is CloudFormation? 
AWS CloudFormation is a service that helps define and provision AWS infrastructure as code using templates. It automates the process of creating and managing AWS resources.

How Does It Relate to EKS?
When you run eksctl, it generates CloudFormation templates behind the scenes to create:
1. The EKS control plane.
2. Node groups.
CloudFormation ensures that these resources are created and managed as a stack (a logical grouping of resources).

What Is a Stack in CloudFormation?
A CloudFormation Stack is a collection of AWS resources (like VPCs, subnets, EC2 instances, etc.) managed as a single unit. For EKS:
1. eksctl-flask-app-cluster-cluster stack: Creates the EKS control plane.
2. eksctl-flask-app-cluster-nodegroup-flask-app-nodes stack: Creates the worker nodes.

Each stack contains:

1. A template defining the resources (YAML or JSON).
2. Resource dependencies and configurations.

----------------------------------------------------------------------------------

----------------------------------------------------------------------------------

Fleet Requests
Definition: A Fleet Request is an AWS internal process for provisioning EC2 instances. When creating a NodeGroup, EKS uses an Auto Scaling Group (ASG) to request EC2 instances, which count as Fleet Requests.

Why Relevant?: AWS imposes a limit on the number of Fleet Requests per account. If your account exceeds this limit (e.g., due to other active ASGs or EKS clusters), NodeGroup creation fails with the error "You’ve reached your quota for maximum Fleet Requests".
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------

What is a PVC?
1. PVC (PersistentVolumeClaim) is a request for storage by a Kubernetes application. It is bound to a PV (PersistentVolume), which is the actual storage resource.
2. PVCs use StorageClasses to define how the volume should be provisioned (e.g., EBS volumes on AWS, NFS, etc.).
3. When a pod is deployed and needs storage, it will request the storage defined in the PVC.

----------------------------------------------------------------------------------

